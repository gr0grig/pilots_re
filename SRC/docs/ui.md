# Текст и интерфейс

## Общее описание

Подсистема текста и интерфейса движка Pilots отвечает за отображение текстовой информации, управление шрифтами, рендеринг оверлеев (наложений) и отображение игрового курсора. Основная реализация находится в файле text.c.

## Шрифтовая система

### Слоты шрифтов

Шрифтовые данные организованы в слоты, аналогично спрайтам и звукам. Каждый слот шрифта содержит информацию о типе шрифта, данные глифов (символов), атрибуты отображения и параметры рендеринга.

Движок поддерживает до 256 слотов шрифтов, хотя типичная сцена использует значительно меньше — обычно два-три шрифта для разных целей (основной текст, заголовки, системные сообщения).

### Типы шрифтов

Шрифтовая система поддерживает несколько форматов хранения глифов:

**Тип 0 — массив растров.** Каждый символ хранится как отдельный растровый спрайт в массиве. Индекс символа (его ASCII-код) используется для обращения к соответствующему элементу массива. Это наиболее гибкий формат, позволяющий иметь произвольно различные символы.

**Тип 1 — единый растр.** Все символы хранятся в одном большом растровом изображении, расположенные в виде сетки. Позиция конкретного символа вычисляется из его кода и размеров ячейки сетки. Этот формат экономит память за счёт общего заголовка.

**Тип 2 и выше — составные шрифты.** Используются для сложных шрифтовых систем, где символ может состоять из нескольких наложенных элементов (например, для создания эффекта тени или обводки).

### Отложенная загрузка глифов

Шрифты используют механизм отложенной загрузки: при инициализации слота шрифта в память загружаются только метаданные. Данные глифов (растровые изображения символов) загружаются из файла ресурсов при первом обращении к конкретному символу.

Это существенно ускоряет инициализацию сцены, особенно если используются шрифты с большим набором символов, из которых в данной сцене задействована лишь малая часть.

## Рендеринг текста

### Создание текстового объекта

Для отображения текста на экране создаётся специальный объект отрисовки через функцию CreateFontRenderObject. Эта функция принимает индекс шрифта, координаты позиции и флаг, указывающий, является ли текст оверлеем.

Созданный объект привязывается к слоту шрифта и получает все его атрибуты: цвет, режим прозрачности, наложения и прочие параметры рендеринга.

### Отрисовка символов

Отрисовка отдельного символа выполняется функцией рендеринга глифов. Для каждого символа происходит следующее:

По коду символа определяется положение его глифа в данных шрифта. Если глиф ещё не загружен, он загружается из файла ресурсов (отложенная загрузка).

Растровые данные глифа передаются в систему блиттинга. К ним применяются атрибуты шрифта — цвет, режим прозрачности, наложение.

Позиция следующего символа вычисляется с учётом ширины текущего глифа. Строка текста отрисовывается символ за символом, слева направо.

### Атрибуты текста

Каждый слот шрифта определяет атрибуты отображения, которые применяются ко всему тексту, использующему этот шрифт:

**Прозрачность** — символы могут быть полупрозрачными, с прозрачным фоном или полностью непрозрачными.

**Режим наложения** — определяет, как пиксели символа комбинируются с фоном (прямая замена, аддитивное наложение и другие режимы).

**Цвет** — для палитровых шрифтов определяет смещение в палитре, что позволяет отображать один и тот же шрифт разными цветами.

## Система оверлеев

Оверлеи — это графические элементы, которые отрисовываются поверх основной сцены в особом режиме. Они используются для отображения элементов интерфейса, подсказок, индикаторов и других элементов, которые должны располагаться поверх игрового мира.

### Рендеринг оверлеев

Функция RenderOverlaySlot выполняет отрисовку оверлея. Ключевая особенность этой функции — она полностью сохраняет и восстанавливает состояние всех глобальных переменных движка.

Перед отрисовкой оверлея сохраняется текущее состояние: позиции, направления, активные ресурсы, флаги и другие параметры. Затем устанавливается состояние, специфичное для оверлея, и выполняется его отрисовка через стандартный вызов RenderSprite. После завершения отрисовки восстанавливается ранее сохранённое состояние.

Такой подход гарантирует, что отрисовка оверлея никак не повлияет на состояние основной сцены, даже если она использует те же глобальные переменные.

### Данные оверлеев

Оверлеи инициализируются через опкоды 0x60–0x61:

Спрайтовые данные оверлея содержат графику, которая будет отрисована. Координатные данные оверлея определяют, где на экране будет расположен оверлей.

## Курсор мыши

Курсор мыши представлен специальным объектом отрисовки g_CursorObject, который управляется особым образом.

### Обновление позиции

При каждом сообщении WM_MOUSEMOVE координаты курсора обновляются. Объект отрисовки курсора перемещается в новую позицию, а его предыдущее и новое местоположение помечаются как грязные регионы для перерисовки.

### Отображение

Курсор всегда отрисовывается поверх всех остальных элементов — он имеет наивысший приоритет среди объектов отрисовки. Это гарантирует, что курсор всегда виден, независимо от содержимого сцены.

### Режимы курсора

Игра может управлять видимостью и внешним видом курсора:

В одних режимах отображается системный курсор Windows (стрелка). В других — системный курсор скрывается, и вместо него используется игровой спрайтовый курсор. В некоторых режимах курсор полностью скрыт (например, во время воспроизведения видео).

## Текстовый ввод

Для ввода текста (например, имени при сохранении) движок использует сообщение WM_CHAR, которое содержит символьный код нажатой клавиши.

Введённый символ записывается в глобальную переменную charCode структуры VideoConfig. Скрипт, управляющий текстовым полем, считывает этот символ и добавляет его к текущей строке ввода. Отображение вводимого текста выполняется через стандартную систему рендеринга шрифтов.

Обработка специальных клавиш (Backspace для удаления, Enter для подтверждения) выполняется скриптами на основе кода символа.

## Взаимодействие с рендерингом

Текстовые и интерфейсные элементы полностью интегрированы в общую систему рендеринга. Они представлены теми же объектами отрисовки, что и спрайты, и проходят через тот же конвейер: отслеживание грязных регионов, послойная отрисовка, блиттинг в задний буфер.

Это упрощает архитектуру и обеспечивает единообразное поведение: текст корректно перекрывается с другими элементами, участвует в переходах между сценами и обрабатывается системой снимков так же, как и графические объекты.
