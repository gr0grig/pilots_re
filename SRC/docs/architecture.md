# Архитектура и поток выполнения

## Общая архитектура

Движок Pilots представляет собой классическое однопоточное Windows-приложение, построенное вокруг цикла оконных сообщений. Вся работа — обработка ввода, исполнение игровой логики, рендеринг и вывод звука — выполняется последовательно в одном потоке, за исключением звуковых обратных вызовов, которые обрабатываются через оконные сообщения.

Ключевая архитектурная особенность движка — разделение между «движком-плеером» и «игровыми данными». Сам движок не содержит никакой игровой логики. Вся логика закодирована в виде байткод-скриптов, хранящихся в файле данных игры. Движок лишь загружает эти скрипты и исполняет их в своей виртуальной машине, что делает его универсальным интерпретатором.

## Точка входа и инициализация

Выполнение начинается с функции WinMain в файле main.c. При запуске происходит следующая последовательность:

Первым делом инициализируется система отладочного логирования. Затем выполняется настройка видеоконфигурации — определяются параметры экрана, размеры окна, положение на рабочем столе. После этого создаётся главное окно приложения с соответствующими стилями и размерами.

Далее загружается файл данных игры. Движок открывает файл ресурсов и считывает из него таблицу смещений, по которой в дальнейшем будет находить конкретные ресурсы — спрайты, звуки, скрипты, видеоролики.

После загрузки данных инициализируется графическая подсистема. Создаётся контекст устройства GDI, настраивается палитра из 256 цветов, выделяется задний буфер для двойной буферизации.

Наконец, инициализируется звуковая подсистема — открывается устройство вывода звука, подготавливаются буферы, настраивается обратный вызов для повторного заполнения буферов.

## Главный цикл сообщений

После инициализации управление переходит в главный цикл сообщений Windows. Движок использует PeekMessage вместо GetMessage, что позволяет ему не блокироваться в ожидании сообщений и постоянно выполнять игровую логику.

На каждой итерации цикла проверяется наличие оконных сообщений. Если сообщения есть — они обрабатываются через DispatchMessage, который направляет их в оконную процедуру MainWndProc. Если сообщений нет — выполняется очередной кадр игровой логики.

## Обработка оконных сообщений

Оконная процедура MainWndProc обрабатывает следующие типы сообщений:

Сообщения клавиатуры (WM_KEYDOWN, WM_CHAR) преобразуются во внутренний формат ввода. Каждое нажатие клавиши сопоставляется с набором из восьми настраиваемых игровых клавиш. Результат записывается в структуру VideoConfig, откуда его считывает скриптовая система.

Сообщения мыши (WM_MOUSEMOVE, WM_LBUTTONDOWN и другие) обновляют координаты курсора и генерируют внутренние коды событий — например, код -127 для нажатия левой кнопки и -126 для её отпускания.

Сообщение WM_PAINT вызывает перерисовку содержимого окна из заднего буфера.

Сообщение MM_WOM_DONE приходит от звуковой подсистемы, когда аудиобуфер был воспроизведён и готов к повторному заполнению.

## Игровой цикл

Основная логика каждого кадра выполняется функцией ProcessGameFrame из файла gameloop.c. Этот цикл — сердце движка, и он состоит из нескольких фаз.

### Фаза обработки ввода

В начале кадра считывается текущее состояние ввода из структуры VideoConfig. Определяется, какие клавиши нажаты, где находится курсор мыши, были ли нажатия кнопок мыши. Эта информация записывается в игровые флаги, доступные скриптам.

### Фаза исполнения скриптов

Далее управление передаётся виртуальной машине скриптов. VM считывает и исполняет байткод из текущего скриптового контекста. Скрипты могут изменять состояние игровых объектов, запускать анимации, воспроизводить звуки, переключать сцены. Подробнее об этом — в разделе «Виртуальная машина скриптов».

### Фаза обновления анимаций

После выполнения скриптов обновляются все активные анимации. Для каждого объекта отрисовки проверяется, нужно ли перейти к следующему кадру анимации. Если объект изменился — соответствующая область экрана помечается как «грязная» и потребует перерисовки.

### Фаза рендеринга

Завершающая фаза кадра — перерисовка изменённых областей экрана. Движок использует систему «грязных регионов»: перерисовываются только те области, которые изменились с предыдущего кадра. Это существенно экономит ресурсы процессора. Подробнее — в разделе «Система рендеринга».

### Управление частотой кадров

Движок контролирует частоту кадров с помощью функции timeGetTime из мультимедийного API Windows. Целевая частота кадров задаётся в структуре GameLoopData и может варьироваться. Если кадр обработан быстрее отведённого времени, движок ожидает до начала следующего кадра.

## Система контекстов

Важная архитектурная особенность движка — система контекстов. При выполнении вложенных операций (например, отрисовка оверлея внутри основной сцены или воспроизведение видео) текущее состояние движка полностью сохраняется в стек. Это включает все глобальные переменные, текущие позиции в скриптах, состояние объектов отрисовки.

После завершения вложенной операции контекст восстанавливается, и движок продолжает работу с того же места, где был прерван. Эта механика позволяет безопасно вкладывать операции друг в друга — например, скрипт может запустить видео, которое в свою очередь содержит звуковое сопровождение, и после его завершения всё вернётся к исходному состоянию.

Для аварийного восстановления в случае критических ошибок движок использует механизм longjmp, который позволяет немедленно вернуться к верхнему уровню игрового цикла.

## Система снимков

Движок поддерживает механизм «снимков» (snapshots) для быстрого сохранения и восстановления состояния сцены. Снимок включает сжатое состояние тайловой карты, список объектов отрисовки и указатель на данные сцены.

Массив снимков может хранить до 256 записей одновременно. При переходе между сценами текущее состояние сохраняется как снимок, а целевое — восстанавливается из ранее сохранённого. Это обеспечивает быстрые переходы между сценами без необходимости полной перезагрузки ресурсов.

## Диспетчер опкодов ресурсов

Помимо скриптовых опкодов, обрабатываемых виртуальной машиной, движок имеет отдельный диспетчер опкодов ресурсов в функции GameMainLoop. Эти опкоды управляют инициализацией слотов:

- Опкоды 0x20–0x23 инициализируют слоты спрайтов и устанавливают указатели на данные
- Опкоды 0x38–0x3A загружают данные кадров анимации
- Опкоды 0x40–0x43 инициализируют слоты шрифтов и загружают глифы
- Опкоды 0x50–0x52 инициализируют слоты звуков и музыки
- Опкоды 0x60–0x61 загружают данные оверлеев

Каждый опкод считывает параметры из потока данных, выделяет необходимую память и устанавливает связи между структурами данных.

## Управление состоянием

Состояние игры хранится в нескольких местах:

Структура VideoConfig содержит параметры отображения, текущий ввод пользователя, контекст устройства GDI и связанные данные.

Массив глобальных переменных игры (game_globals_struct) представляет собой автоматически сгенерированную структуру размером более четырёх тысяч байт, содержащую все переменные, к которым обращаются скрипты.

Игровые флаги (g_GameFlags1, g_GameFlags2) хранят текущее состояние объектов — направление, позицию, идентификаторы ресурсов, режимы ввода.

Объекты отрисовки (массив RenderObject) описывают все видимые элементы на экране — их позиции, данные спрайтов, флаги видимости и трансформации.

## Завершение работы

При получении сообщения о закрытии окна или при штатном завершении игры движок выполняет очистку в обратном порядке: останавливает воспроизведение звука, освобождает звуковые буферы, освобождает графические ресурсы, закрывает файл данных и завершает процесс.
