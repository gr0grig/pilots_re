# Виртуальная машина скриптов

## Общее описание

Виртуальная машина (VM) — центральный компонент движка Pilots. Именно она исполняет всю игровую логику: управление сценами, реакцию на действия игрока, анимации, переходы и диалоги. VM реализована в файле script.c и представляет собой стековый интерпретатор байткода.

Движок не содержит захардкоженной игровой логики — всё поведение определяется скриптами, предварительно скомпилированными в байткод и хранящимися в файле ресурсов.

## Архитектура виртуальной машины

VM построена по классической аккумуляторно-стековой схеме. Она имеет:

**Аккумулятор** — основной рабочий регистр, в котором хранится результат последней арифметической или логической операции. Большинство операций читают один операнд из стека и комбинируют его с аккумулятором.

**Стек** — область памяти для хранения промежуточных значений, параметров функций и адресов возврата. Стек растёт вверх при записи и уменьшается при чтении.

**Счётчик команд** — указатель на текущую позицию в потоке байткода. После выполнения каждой инструкции счётчик продвигается на размер этой инструкции.

**Область глобальных переменных** — большой блок памяти (более 4000 байт), к которому скрипты обращаются для чтения и записи игровых данных. Эта область описана структурой game_globals_struct.

## Набор инструкций

VM поддерживает более 55 различных опкодов, которые можно разделить на несколько категорий.

### Операции сравнения

Инструкции сравнения сопоставляют значение аккумулятора со значением на вершине стека (или с непосредственным операндом). Результат сравнения записывается в аккумулятор: единица означает истину, ноль — ложь.

Поддерживаются все стандартные операции: равенство, неравенство, меньше, больше, меньше или равно, больше или равно. Существуют как знаковые, так и беззнаковые варианты сравнений.

### Операции перехода

Инструкции переходов изменяют счётчик команд, перенаправляя поток выполнения. Безусловный переход просто устанавливает новый адрес. Условные переходы проверяют значение аккумулятора и выполняют переход, только если условие истинно (аккумулятор не равен нулю) или ложно (аккумулятор равен нулю).

Существуют также инструкции относительного перехода, которые добавляют смещение к текущему счётчику команд, что позволяет создавать позиционно-независимый код.

### Арифметические операции

VM поддерживает базовый набор арифметических операций: сложение, вычитание, умножение, деление и взятие остатка от деления. Все операции выполняются над целыми числами. Один операнд берётся из аккумулятора, второй — из стека. Результат помещается в аккумулятор.

### Логические и битовые операции

Поддерживаются логические операции И, ИЛИ и НЕ, а также побитовые операции. Логическое НЕ инвертирует значение аккумулятора: ноль превращается в единицу, любое ненулевое значение — в ноль.

### Операции со стеком

Инструкция помещения в стек (push) копирует значение аккумулятора на вершину стека. Извлечение из стека (pop) забирает значение с вершины и помещает его в аккумулятор.

### Операции с памятью

Скрипты могут читать и записывать значения в область глобальных переменных по смещению. Поддерживается чтение и запись байтов, слов (2 байта) и двойных слов (4 байта). Адресация выполняется через смещение от начала области глобальных переменных.

Также поддерживается косвенная адресация — адрес вычисляется во время выполнения из значения аккумулятора или другого смещения.

### Вызовы функций

VM поддерживает два типа вызовов:

**Вызов скриптовых функций** — адрес возврата помещается в стек, а счётчик команд устанавливается на адрес вызываемой функции. При возврате адрес извлекается из стека.

**Вызов нативных функций** — особый тип вызова, при котором управление передаётся из VM в скомпилированный C-код. Параметры передаются через стек VM. Нативные функции реализованы в файле native_funcs.c и предоставляют скриптам доступ к низкоуровневым возможностям движка.

## Нативные функции

Библиотека нативных функций содержит 57 функций, вызываемых из скриптов. Они обеспечивают интерфейс между скриптовой логикой и подсистемами движка.

Нативные функции можно разделить на группы:

**Функции запроса состояния** — проверяют текущий режим ввода (активен ли режим клавиатурного ввода, режим ожидания клика), запрашивают состояние анимации, проверяют направление движения.

**Функции управления отображением** — определяют, завершён ли переход между сценами, проверяют состояние видеосчётчика, запрашивают параметры текущей сцены.

**Функции ввода** — считывают координаты курсора, определяют нажатые клавиши, проверяют попадание курсора в заданную область.

**Функции мультимедиа** — управляют воспроизведением звуков и музыки, запрашивают текущий трек.

При вызове нативной функции VM извлекает её индекс из потока байткода, подготавливает параметры на стеке и передаёт управление соответствующей C-функции. Результат записывается в аккумулятор VM.

## Контекст выполнения

VM поддерживает вложенное выполнение скриптов через механизм сохранения и восстановления контекста. Контекст включает:

- Текущий счётчик команд
- Содержимое стека
- Значение аккумулятора
- Текущий указатель на данные скрипта
- Состояние глобальных переменных

Перед запуском вложенного скрипта (например, при отрисовке оверлея или обработке события) текущий контекст сохраняется. После завершения вложенного скрипта контекст восстанавливается, и основной скрипт продолжает выполнение.

Глубина вложенности ограничена размером стека сохранённых контекстов, но для типичных сценариев использования этого более чем достаточно.

## Взаимодействие с игровым циклом

На каждом кадре игровой цикл вызывает VM для исполнения очередной порции байткода. VM исполняет инструкции до тех пор, пока не встретит инструкцию ожидания (yield), завершения сцены или исчерпания бюджета инструкций на кадр.

Инструкция ожидания возвращает управление игровому циклу, позволяя обработать следующий кадр — обновить экран, обработать ввод, воспроизвести звук. На следующем кадре VM продолжит выполнение с того же места.

Это создаёт кооперативную многозадачность: скрипты добровольно отдают управление движку для обработки кадров, что обеспечивает плавную работу всех подсистем.

## Обработка ошибок

При встрече неизвестного опкода VM прекращает выполнение текущего скрипта. Критические ошибки (переполнение стека, обращение за пределы памяти) могут привести к использованию механизма longjmp для аварийного возврата к верхнему уровню игрового цикла.

Отладочная информация о выполнении скриптов может выводиться через систему логирования, что помогает при анализе проблем.
