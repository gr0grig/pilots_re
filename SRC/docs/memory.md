# Управление памятью

## Общее описание

Движок Pilots реализует собственную систему управления памятью, не полагаясь на стандартный аллокатор C (malloc/free). Это типичный подход для игровых движков того периода, когда контроль над распределением памяти был критически важен для производительности и стабильности. Реализация находится в файле memory.c.

## Двойная система пулов

Движок использует два раздельных пула памяти, каждый из которых обслуживает свой тип данных.

### Основной пул памяти

Основной пул — это большой непрерывный блок памяти размером в несколько мегабайт, выделяемый при запуске через Windows API. Он описывается структурой MemoryPoolDescriptor, содержащей размер пула, базовый адрес и указатель на список свободных блоков.

Из этого пула выделяется память для всех игровых ресурсов: данных спрайтов, звуков, шрифтов, скриптов, буферов декомпрессии и других структур данных.

### Пул объектов отрисовки

Второй пул предназначен исключительно для объектов отрисовки (RenderObject). Он расположен в отдельной области памяти и работает по другому принципу — нисходящему выделению фиксированных блоков по 16 байт.

Разделение на два пула позволяет избежать фрагментации: часто создаваемые и уничтожаемые объекты отрисовки не перемешиваются с долгоживущими ресурсами, что предотвращает образование «дыр» в памяти.

## Аллокатор основного пула

Основной пул поддерживает два режима выделения памяти.

### Простое выделение (bump allocator)

Функция AllocMemoryChunk реализует простейший аллокатор типа «bump pointer». Указатель выделения продвигается вперёд на запрошенный размер, выровненный до 4 байт. Этот метод максимально быстр (одна операция — сдвиг указателя), но не поддерживает освобождение отдельных блоков.

Простое выделение используется для данных, которые будут существовать до конца сцены или до перезагрузки пула. Оно идеально для ресурсов, загружаемых при инициализации.

### Выделение со списком свободных блоков

Функция AllocFromMemoryPool реализует более сложный аллокатор с поддержкой повторного использования освобождённой памяти. Свободные блоки организованы в связный список. При запросе выделения аллокатор ищет в списке блок подходящего размера.

Если найденный блок больше запрошенного, он разделяется на две части: выделенную и остаток, который возвращается в список свободных. Заголовок каждого блока хранит его размер, а бит 31 размера используется как флаг — установленный бит означает, что блок занят.

Этот режим используется для данных с динамическим временем жизни — например, для буферов декомпрессии или временных структур.

## Освобождение памяти

Функция FreeMemoryBlock возвращает ранее выделенный блок в пул свободной памяти. При освобождении выполняется коалесценция — объединение смежных свободных блоков в один более крупный.

Коалесценция критически важна для предотвращения фрагментации. Без неё множество мелких освобождённых блоков не смогли бы удовлетворить запрос на крупное выделение, даже если суммарно свободной памяти достаточно. Объединение соседних блоков решает эту проблему.

Процесс коалесценции: после освобождения блока проверяется, свободен ли блок непосредственно перед ним и непосредственно после него. Если один или оба соседних блока свободны, они объединяются в один крупный свободный блок.

## Временные буферы

Для кратковременных потребностей в памяти движок предоставляет специальный механизм выделения временных буферов через функцию AllocTempBuffer.

Эта функция реализует стратегию с тремя уровнями:

Если запрошенный размер невелик (до 152 байт), используется статический буфер g_SmallTempBuffer. Это самый быстрый вариант — никакого выделения не происходит, возвращается указатель на заранее подготовленную область.

Для средних запросов выделение выполняется из области пула объектов отрисовки, если там есть свободное пространство.

Для крупных запросов используется основной пул через AllocFromMemoryPool.

Временные буферы используются для промежуточных вычислений, буферизации ввода-вывода и других операций, где данные нужны лишь на короткое время.

## Выделение памяти для опкодов

Буферы для хранения опкодов (байткода скриптов и опкодов ресурсов) выделяются отдельной функцией, которая учитывает специфику их использования. Опкоды обычно загружаются целыми блоками и существуют на протяжении всей сцены, поэтому для них оптимален простой bump-аллокатор.

## Выравнивание

Все выделения памяти в основном пуле выравниваются до границы 4 байт. Это обеспечивает корректный доступ к данным на архитектурах, требующих выравнивания, и улучшает производительность на процессорах, для которых выровненный доступ быстрее невыровненного.

Размер запрошенного блока округляется вверх до ближайшего кратного четырём перед выделением.

## Управление памятью пула объектов отрисовки

Пул объектов отрисовки управляется двумя указателями: на начало и конец занятой области. Выделение нового объекта сдвигает начальный указатель вниз (к младшим адресам), а освобождение может сдвинуть его обратно вверх.

Поскольку объекты имеют фиксированный размер (16 байт), фрагментация внутри этого пула минимальна. Свободные слоты в середине пула обнаруживаются по флагу выделения при следующем запросе.

## Общая стратегия

Стратегия управления памятью в движке построена на нескольких принципах:

Предсказуемость — использование пулов с заранее известным максимальным размером гарантирует, что память не закончится неожиданно в середине работы.

Минимизация фрагментации — разделение на два пула, коалесценция свободных блоков и фиксированный размер объектов отрисовки сводят фрагментацию к минимуму.

Скорость выделения — простые алгоритмы (bump pointer, поиск в коротком списке) обеспечивают минимальные накладные расходы на выделение памяти.

Группированное освобождение — при переходе между сценами можно сбросить bump-указатель, мгновенно освободив все ресурсы текущей сцены без необходимости освобождать каждый блок отдельно.
